{"id":3,"title":"AngularJS Route Resolve Example","summary":"The resolve property is attached to a route in AngularJS to provide a list of dependencies for the route. The data from this list is injected into the route controller and if any of the dependencies are promises, the promise will be resolved before the controller is instantiated. This helps keep the controller clean because any data the controller depends on can be injected into it instead of the controller retrieving that data itself. This post will go through an example of using the resolve property and show the differences between using a resolve property versus putting the fetch code in the controller directly.","body":"The resolve property is attached to a route in AngularJS to provide a list of dependencies for the route. The data from this list is injected into the route controller and if any of the dependencies are promises, the promise will be resolved before the controller is instantiated. This helps keep the controller clean because any data the controller depends on can be injected into it instead of the controller retrieving that data itself. This post will go through an example of using the resolve property and show the differences between using a resolve property versus putting the fetch code in the controller directly. The full example can be found in <a href=\"https://plnkr.co/edit/bHUJQM\" target=\"_blank\">this plunk.</a> It's a little confusing just looking at code snippets so I suggest opening the example in another window and following along.\r\n<br />\r\n<br />\r\nI'm going to start with an example of using the controller directly. There is a simple template that displays a greeting. This is in greetingTemplate.html.\r\n<pre>\r\n<code class=\"language-markup\">\r\n&lt;p&gt;Greeting Below&lt;/p&gt;\r\n&lt;p&gt;{{answer}}&lt;/p&gt;\r\n</code>\r\n</pre>\r\n<br />\r\nNext, there is a greeting service that returns a promise with a greeting. The result is wrapped in a $timeout call to simulate a long running process, such as retreiving data from an API.\r\n<pre>\r\n<code class=\"language-javascript\">\r\napp.service('greetingService', function($q, $timeout) {\r\n     var _this = this;\r\n     _this.getGreeting = function() {\r\n          return $q(function(resolve, reject) {\r\n               $timeout(function() {\r\n                    console.log(\"Inside promise\");\r\n                    resolve(\"Hello from the greetings service\");\r\n               },5000);\r\n          });\r\n     };\r\n});\r\n</code>\r\n</pre>\r\n<br />\r\nThe controller fetches the greeting from the greeting service and sets the answer property that is shown in the template. It's called when the controller is instantiated. This section of the controller can get quite large if it needs several pieces of data.\r\n<pre>\r\n<code class=\"language-javascript\">\r\napp.controller('greetingCtrl', function($scope, greetingService) {\r\n    // Call service from beginning of controller directly. Route is resolved without waiting for this\r\n    var greetingPromise = greetingService.getGreeting();\r\n    greetingPromise.then(function(greeting) {\r\n        console.log(greeting);\r\n        $scope.answer = \"Successful Greeting = \"+greeting;\r\n      }, function(failure) {\r\n          $scope.answer = failure;\r\n          console.log(\"UI failure message\");\r\n        });\r\n});\r\n</code>\r\n</pre>\r\n<br />\r\nFinally, the route that puts it all together.\r\n<pre>\r\n<code class=\"language-javascript\">\r\n$routeProvider.when('/', {\r\n        templateUrl: 'greetingTemplate.html',\r\n        controller: 'greetingCtrl'\r\n    });\r\n</code>\r\n</pre>\r\n<br />\r\n<br />\r\nNext I'll show an example of replacing the code in the controller with the resolve property on the route. If you're following along in the example, comment out the top half of script.js and uncomment the bottom half. This has the updated route using the resolve property.\r\n<br />\r\n<br />\r\nThe modified route is below. Notice the <strong>resolve</strong> property is an object that has a property of it's own called 'greeting'. The greeting property is a function that takes the greetingService as a dependency and returns a call to getGreeting(). That's a mouthful but basically we're taking the greetingService dependency and moving it from the <strong>controller</strong> to the <strong>route</strong>. In this case the 'greetingCtrl' controller will not be instantiated until the call to greetingService.getGreeting() is resolved.\r\n<pre>\r\n<code class=\"language-javascript\">\r\n$routeProvider.when('/', {\r\n      templateUrl: 'greetingTemplate.html',\r\n      controller: 'greetingCtrl',\r\n      // When the resolve property is used in the route, the route will wait to return until all properties of the object are resolved\r\n      resolve: {\r\n        greeting: function(greetingService){\r\n            return greetingService.getGreeting();\r\n        }\r\n      }\r\n    });\r\n</code>\r\n</pre>\r\n<br />\r\nLastly, this is the updated controller. It takes a paramter called <strong>greeting</strong>. This matches the name of the resolve property on the route above and contains the data returned by the greetingService.getGreeting() promise. It is important to note that even though getGreeting returns a promise, the value of the greeting parameter in the controller is \"Hello from the greetings service\". This is the value of the <strong>resolved</strong> promise. Because of this, the controller can simply use the data that is passed in.\r\n<pre>\r\n<code class=\"language-javascript\">\r\napp.controller('greetingCtrl', function($scope, greeting) {\r\n     $scope.answer = greeting;\r\n});\r\n</code>\r\n</pre>\r\n<br />\r\n<br />\r\nThere is one point I should address before wrapping up. If there are long running operations being performed by the resolve properties, it could take a while before the page is rendered since all properties are resolved before the controller is instantiated. If time to first page draw is most important this method probably isn't for you and you will probably prefer handling dependencies in the controller and using a loading widget in the templates to specify which dependencies are still loading. This can be seen in the example. It takes 5 seconds for the service to resolve the promise so the second version of the route will take 5 seconds before anything is rendered to the page. The first line of the template renders immediately in the version of the route that doesn't use resolve.\r\n<br />\r\n<br />\r\nIn conclusion, the resolve property of a route can organize controller dependencies on the route object directly and make controller code smaller. Multiple properties can be passed into resolve if the controller has multiple dependencies. Services can be injected into functions used by the resolve property as well so the heavy lifting can still be done in services. The remaining question I have for all of this is what happens when a promise fails? Does the route load? I'll look at this in my next post.","author":"Carl Layton","publishedDate":"2017-12-27T13:00:00","friendlyUri":"angularjs-route-resolve-example","isPublished":true,"previousPostUri":"using-javascript-promises-for-application-logic-in-an-angularjs-service","previousPostTitle":"Using Javascript Promises for Application Logic in an AngularJS Service","nextPostUri":null,"nextPostTitle":null}