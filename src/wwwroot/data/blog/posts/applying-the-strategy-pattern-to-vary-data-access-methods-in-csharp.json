{"id":6,"title":"Applying The Strategy Pattern To Vary Data Access Methods In C#","summary":"The strategy pattern is a design pattern that allows for multiple implementations, or strategies, to be used interchangeably. A data access layer can make good use of the strategy pattern because it can abstract out the implementation of the actual data access mechanism from the consumer of the data access layer. In this post, I'll look at an example that uses the strategy pattern to implement 2 different data access methods and switching between them is as easy as updating the dependency injector configuration.","body":"The <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Strategy_pattern\">strategy pattern</a> is a design pattern that allows for multiple implementations, or strategies, to be used interchangeably. Below is a diagram of the overall design.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/applying-the-strategy-pattern-to-vary-data-access-methods-in-csharp/StrategyPatternDiagram.png\" alt-text=\"strategy pattern diagram\" width=\"75%\" height=\"75%\" />\r\n<br /><br />\r\nA data access layer can make good use of the strategy pattern because it can abstract out the implementation of the actual data access mechanism from the consumer of the data access layer. The actual data store can be a file, a relational database, an in memory object, or something else. The caller only knows about the actions exposed by the interface. This is no different from any other use of abstraction with one key advantage. The caller can choose which implementation to use at runtime or through dependency injection configuration. This allows the app to use different data access mechanisms without changing the actual application code. For example, an in memory object can be used while a more robust implementation that uses a relational database is being developed. Maybe early on it's not clear what is needed so a simple csv file is used at first and then expanded or changed later or maybe not. In theory, this flexibility is offered without breaking the calling code.\r\n<br /><br />\r\nTo show this in action I created a simple CRUD web app using a dotnet core mvc project. The source code is available on <a target=\"_blank\" href=\"https://github.com/cwl157/strategypattern-dal-example\">github</a>. The application keeps track of a list of books.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/applying-the-strategy-pattern-to-vary-data-access-methods-in-csharp/BookListFront.png\" alt-text=\"strategy pattern diagram\" width=\"75%\" height=\"75%\" />\r\n<br /><br />\r\nI created 2 data access strategies for this application. One that uses an in memory object and one that uses a csv file. Here is a class diagram.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/applying-the-strategy-pattern-to-vary-data-access-methods-in-csharp/DataAccessDiagram.png\" alt-text=\"strategy pattern diagram\" width=\"75%\" height=\"75%\" />\r\n<br /><br />\r\nThe data access project starts with a simple Model to represent a book.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class Book\r\n{\r\n     public int Id { get; set; }\r\n     public string Title { get; set; }\r\n     public string Author { get; set; }\r\n     public DateTime PublishDate { get; set; }\r\n     public int PageLength { get; set; }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe IBookData interface defines the actions.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic interface IBookData\r\n{\r\n     IEnumerable<Book> Books { get; }\r\n     Book GetById(int id);\r\n     Book Save(Book b);\r\n     Book DeleteById(int id);\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThere are 2 implementations of the interface. <code class=\"language-csharp\">CsvBookData</code> and <code class=\"language-csharp\">InMemoryBookData</code>. I am not going to show the implementation details of those here but they can be found in the <a target=\"_blank\" href=\"https://github.com/cwl157/strategypattern-dal-example\">GitHub repository</a>.\r\nThe MVC controllers use constructor dependency injection to inject the IBookData dependency. Below is the constructor for the HomeController as an example. There is also an update controller to handle create, update, and delete but the constructors work the same.\r\n<pre>\r\n<code class=\"language-csharp\">\r\n// Home Controller\r\nprivate IBookData _bda;\r\npublic HomeController(IBookData b)\r\n{\r\n     _bda = b;\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThis allows me to switch data access strategies by updating one line in the Startup.ConfigureServices method to change which implementation gets instantiated for IBookData, either the in memory option or the csv option.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n     services.AddMvc();\r\n     services.AddTransient&lt;IBookData, InMemoryBookData&gt;();\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nIn conclusion, the strategy pattern is straight forward and can be very powerful in adding flexibility to a code base. The strategy pattern works well for a data access layer because there are so many options for data access and it usually changes throughout a project's lifecycle. The full code for this example is available on <a target=\"_blank\" href=\"https://github.com/cwl157/strategypattern-dal-example\">GitHub</a>.","author":"Carl Layton","publishedDate":"2018-04-04T11:30:00Z","friendlyUri":"applying-the-strategy-pattern-to-vary-data-access-methods-in-csharp","isPublished":true,"previousPostUri":"create-fake-data-using-json-schema-faker","previousPostTitle":"Create Fake Data Using Json Schema Faker","nextPostUri":null,"nextPostTitle":null}