{
    "id": 2,
    "title": "Using Javascript Promises for Application Logic in an AngularJS Service",
    "summary": "",
    "body": "<strong>\"A Promise is an object representing the eventual completion or failure of an asynchronous operation\"</strong> - <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises'>MDN Web Docs</a> AngularJS has a <a href='https://promisesaplus.com/'> Promises/A+-compliant</a> implementation of javascript promises in its <a href='https://docs.angularjs.org/api/ng/service/$q'>$q service</a>. For example, it uses this in the <a href='https://docs.angularjs.org/api/ng/service/$http'>$http service</a> to make asynchronous HTTP calls. The $q service is also available on its own and provides a convenient API for creating and consuming promises within an AngularJS application. This allows a developer to harness the power of promises for more than AJAX calls. We can use promises in all kinds of application specific contexts. This can help keep application code organized. The following example shows how the $q service can be used to separate application logic in an angular service and controller and keep the responsibility of each in the appropriate place. The full working example is <a href='https://plnkr.co/edit/Vde2F6eSqdGBX7KdYZ55'>available in this plunk.</a><br /><br />The example divides 2 numbers and produces an error if attempting to divide by 0. Javascript returns infinity by default when trying to divide by 0 so my division service checks for this condition and returns an error when attempting to divide by 0. There is a simple template that contains 2 input fields, a button to divide them, and a placeholder for either the result of the division or an error message.<pre>&lt;label&gt;Divide numbers:&lt;/label&gt;&lt;input type=\"text\" name=\"num1\" ng-model=\"num1\" id=\"num1\" /&gt; / &lt;input type=\"text\" name=\"num2\" ng-model=\"num2\" id=\"num2\" /&gt;<br />&lt;button ng-click=\"divide()\"&gt;Divide&lt;/button&gt;<br />&lt;p&gt;{{answer}}&lt;/p&gt;</pre><br />The controller keeps track of num1 and num2 populated in the template and contains the divide() function called from the ng-click directive above. This function calls into the division service that actually performs the division and returns the quotient or an error. This is where things get interesting. The divide function in the <strong>service</strong> returns a promise that executes the division. The service checks for a divide by zero condition and only executes the division and resolves the promise if it’s not dividing by 0. If it is dividing by 0, the promise is rejected. Below is the divide function in the service.<pre>\r\n_this.divide = function(num1, num2) {\r\n\treturn $q(function(resolve, reject) {\r\n\t\tif (num2 != 0) {\r\n\t\t\tvar result = num1/num2;\r\n\t\t\tresolve(result);\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// Handle service level error handling here\r\n\t\t\tconsole.log(\"Invalid Division\");\r\n\t\t\treject(\"Divide by 0 error\");\r\n\t\t }\r\n\t});\r\n};\r\n</pre><br />Because the function returns the promise itself, the <strong>controller</strong> can consume the promise from the service. This allows the controller to handle the success or failure of the promise in the appropriate context of the controller. In this case, if it’s successful set the answer property to the quotient and if it fails, set the answer property to an error message. Both of these are UI specific operations, therefore, both are appropriate to handle in the controller as highlighted below.<pre>var dividePromise = divisionService.divide($scope.num1, $scope.num2);\r\ndividePromise.then(function(quotient) {\r\n\t$scope.answer = \"Successful Quotient = \"+quotient;\r\n}, function(failure) {\r\n\t// Handle UI level error handling here\r\n\t$scope.answer = failure;\r\n\tconsole.log(\"UI failure message\");\r\n});</pre><br />The <strong>service</strong> can still handle the application logic and low level error handling while leaving the controller to fulfill its responsibility of managing the UI. Here is the promise that gets returned in the division service.<pre>return $q(function(resolve, reject) {\r\n\tif (num2 != 0) {\r\n\t\tvar result = num1/num2;\r\n\t\tresolve(result);\r\n\t}\r\n\telse {\r\n\t\t// Handle service level error handling here\r\n\t\tconsole.log(\"Invalid Division\");\r\n\t\treject(\"Divide by 0 error\");\r\n\t}\r\n}</pre><br />In conclusion, promises are a great way to implement business logic in AngularJS services. They can keep controllers clean and focused on the UI, while allowing business logic to be organized through services based on specifics of the application.",
    "author": "Carl Layton",
    "publishedDate": "2017-12-15T05:00:00Z",
    "friendlyUri": "using-javascript-promises-for-application-logic-in-an-angularjs-service",
    "isPublished": true,
    "comments": []
}