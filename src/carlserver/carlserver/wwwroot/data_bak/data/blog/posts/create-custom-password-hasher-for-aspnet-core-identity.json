{"id":11,"title":"Create Custom Password Hasher for ASP .NET Core Identity","summary":"In this post, I will look at how to extend the ASP .NET Core Identity membership system to use a custom class for hashing passwords. ASP .NET Core Identity is very extendable and extending it is a good way to get a better understanding of how the system works. We can customize it by providing new implementations to its interfaces. As with any custom security implementation, customization should be done with care and be backed by good reasons. That being said, lets have some fun. This tutorial requires Visual Studio 2017, dotnet core 2.0, and LocalDb.","body":"In this post, I will look at how to extend the ASP .NET Core Identity membership system to use a custom class for hashing passwords. ASP .NET Core Identity is very extendable and extending it is a good way to get a better understanding of how the system works. We can customize it by providing new implementations to its interfaces. This code is not production ready and any custom security implementation should be done with care and be backed by good reasons. That being said, lets have some fun. This tutorial requires <a target=\"_blank\" href=\"https://visualstudio.microsoft.com/downloads/\">Visual Studio 2017</a>, <a target=\"_blank\" href=\"https://www.microsoft.com/net/download\">dotnet core 2.0</a>, and LocalDb, which should be installed with Visual Studio depending on which components were picked at the time of install. The entire sample project is available <a target=\"_blank\" href=\"https://github.com/cwl157/asp-net-core-auth-examples\">on Github.</a>\r\n<br /><br />\r\nStart by opening Visual Studio 2017 and create a new ASP .NET Core Web Application project. I named it <code>DotNetCoreAuthExamples</code> but you can name it anything you like. Click OK.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-password-hasher-for-aspnet-core-identity/create_project.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nChoose <code>.NET Core</code> and <code>ASP.NET Core 2.0</code> from the dropdowns at the top. Select <code>Web Application (Model-View-Controller)</code> for the template and select Change Authentication and pick <code>Individual User Accounts</code>.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-password-hasher-for-aspnet-core-identity/create_project_dotnetcore.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nAfter the project is created, debug it from Visual Studio. Once the website loads, click the <code>Register</code> link from the top menu bar. Fill in an email and password and click the Register button.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-password-hasher-for-aspnet-core-identity/register_form.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nThe first time an error will appear. This is because we havenâ€™t created the database yet. Click on Apply Migrations. This will create the database using Entity Framework. All the required database stuff is defined by the template and the defaults will work for this demonstration.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-password-hasher-for-aspnet-core-identity/database_migrations_error.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nOnce that is done, the button text changes to Migrations Applied. Refresh the page and click yes at any browser prompts about resubmitting the form. The home page will reload and the top menu bar will show the test user logged in.\r\n<br /><br />\r\nIf you get an error starting with <code>SqlException: A network-related or instance-specific error occurred while establishing a connection to SQL Server...</code> check the server in the app settings connection string. This can be found in the <code>appsettings.json</code> file. The Visual Studio <code>Sql Server Object Explorer</code> will tell you the server path to LocalDb. Make sure the connection string matches this path. If not, change it and then stop and restart debugging.\r\n<br /><br />\r\nAfter the page reloads with the user logged in, a record is also created in the database for this user. To see that, open the <code>SQL Server Object Explorder</code> in Visual Studio. It should auto-connect to LocalDb. The database name will contain the project name. Once you find it, query the AspNetUsers table like this <code class=\"language-sql\">SELECT * FROM dbo.AspNetUsers</code>. There is 1 row with the registered user.\r\n<br /><br />\r\nAs this point, we have a working default MVC template with Individual User Accounts. We will now supplement this with a class to do our own password hashing. This is to demonstrate how different components of the Identity membership system can be customized. Create a new class named <code class=\"language-csharp\">CustomPasswordHasher</code> and have it implement <code class=\"language-csharp\">IPasswordHasher&lt;ApplicationUser&gt;</code>. There are 2 methods we need to implement, <code class=\"language-csharp\">string HashPassword(TUser user, string password)</code> and <code class=\"language-csharp\">PasswordVerificationResult VerifyHashedPassword(TUser user, string hashedPassword, string providedPassword)</code>. Our custom class will reverse the original password string. This is to demonstrate how the methods will be used. In a real application, this would contain a secure, well planned, and well tested implementation. The full class is below. This should not be used in a real application.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class CustomPasswordHasher : IPasswordHasher&lt;ApplicationUser&gt;\r\n{\r\n    public string HashPassword(ApplicationUser user, string password)\r\n    {\r\n        return ReversePassword(password);\r\n    }\r\n\r\n    public PasswordVerificationResult VerifyHashedPassword(ApplicationUser user, string hashedPassword, string providedPassword)\r\n    {\r\n        if (hashedPassword == ReversePassword(providedPassword))\r\n        {\r\n            return PasswordVerificationResult.Success;\r\n        }\r\n\r\n        return PasswordVerificationResult.Failed;\r\n    }\r\n\r\n    private string ReversePassword(string value)\r\n    {\r\n        // This is not a secure way to store a password!\r\n        char[] charArray = value.ToCharArray();\r\n        Array.Reverse(charArray);\r\n        return new string(charArray);\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe final thing to do is register our new implementation with the dependency injection system. This happens in the <code class=\"language-csharp\">ConfigureServices</code> method of the <code class=\"language-csharp\">Startup</code> class. Copy/Paste the following line as the first line of the method: <code class=\"language-csharp\">services.AddTransient&lt;IPasswordHasher&lt;ApplicationUser&gt;, CustomPasswordHasher&gt;();</code>. To learn more about Dependency injection in ASP .NET Core, check out my post <a target=\"_blank\" href=\"/blog/post/asp-dotnet-core-mvc-dependency-injection-overview\">\"ASP .NET Core MVC Dependency Injection Overview\".</a> The full <code class=\"language-csharp\">ConfigureServices</code> method is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddTransient&lt;IPasswordHasher&lt;ApplicationUser&gt;, CustomPasswordHasher&gt;();\r\n\r\n    services.AddDbContext&lt;ApplicationDbContext&gt;(options =&gt;\r\n\t\toptions.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\")));\r\n\r\n    services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;()\r\n        .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()\r\n        .AddDefaultTokenProviders();\r\n\r\n\t// Add application services.\r\n\tservices.AddTransient&lt;IEmailSender, EmailSender&gt;();\r\n\r\n\tservices.AddMvc();  \r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe only thing left to do is test it. Place a breakpoint in both the HashPassword and VerifyHashedPassword methods. Start debugging and register a new user, like we did above. On registration, the HashPassword breakpoint will be hit and on login the VerifyHashedPassword method will be hit. In both cases, the user will be logged in. If you got this far, it means you have successfully created a custom password hasher for ASP .NET Core Identity!\r\n<br /><br />\r\nIn conclusion, this post shows 1 example of overriding a feature of ASP .NET Core Identity. The complete code can be found <a target=\"_blank\" href=\"https://github.com/cwl157/asp-net-core-auth-examples\">in this Github repository.</a> This code is for educational purposes only and is not meant for production environments. Thought, planning, and good reasons need to be involved for authentication code meant for a production environment. That being said, it is possible to customize many parts of the ASP .NET Core Identity system. In my next post, I will expand on this with an example of customizing the user store component to allow user accounts to be stored in memory instead of a database.","author":"Carl Layton","publishedDate":"2018-09-06T01:00:00Z","friendlyUri":"create-custom-password-hasher-for-aspnet-core-identity","isPublished":true,"previousPostUri":"use-identityserver-to-implement-a-custom-sitefinity-identity-provider","previousPostTitle":"Use IdentityServer to Implement a Custom Sitefinity Identity Provider","nextPostUri":"create-custom-user-store-for-aspnet-core-identity","nextPostTitle":"Create Custom User Store for ASP .NET Core Identity","tags":["ASP .NET Core","Authentication","csharp","Identity"]}