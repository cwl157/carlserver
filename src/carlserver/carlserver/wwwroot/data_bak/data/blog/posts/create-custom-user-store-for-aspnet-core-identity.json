{"id":12,"title":"Create Custom User Store for ASP .NET Core Identity","summary":"In this post, I will look at how to extend the ASP .NET Core Identity membership system to use a custom user store. This will store users in memory and not a database. This would not be useful in a production application because the list of users resets every time the application is started. However, by customizing ASP .NET Core Identity, we gain a better understanding of the components and how they fit together. This tutorial requires Visual Studio 2017 and dotnet core 2.0.","body":"In the <a href=\"/blog/post/create-custom-password-hasher-for-aspnet-core-identity\">previous post</a> I looked at how to create a custom password hasher for ASP .NET Core Identity. In this post, I continue customizing the Identity system by creating a custom User Store. This is done by providing custom implementations to the <code class=\"language-csharp\">IUserPasswordStore<ApplicationUser></code> and <code class=\"language-csharp\"> IUserEmailStore<ApplicationUser></code> interfaces. I'm going to create in-memory implementations of these two interfaces.  This will not work in a real application because all the users are deleted when the application restarts but is good for demo purposes. This tutorial requires <a target=\"_blank\" href=\"https://visualstudio.microsoft.com/downloads/\">Visual Studio 2017</a> and <a target=\"_blank\" href=\"https://www.microsoft.com/net/download\">dotnet core 2.0</a>. The entire sample project is available <a target=\"_blank\" href=\"https://github.com/cwl157/asp-net-core-auth-examples\">on Github.</a>\r\n<br /><br />\r\n<h3>Create Starting Application</h3>\r\n<br />\r\nThe first step is to create a new ASP .NET Core web app with individual user accounts. We're going to start with this template because a lot of the boilerplate code is created automatically and it's a good starting point to customize ASP .NET identity. Open Visual Studio 2017 and create a new ASP .NET Core Web Application project. Provide a name and location and click OK.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity/create_project.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nChoose <code>.NET Core</code> and <code>ASP.NET Core 2.0</code> from the dropdowns at the top. Select <code>Web Application (Model-View-Controller)</code> for the template and select Change Authentication and pick <code>Individual User Accounts</code>.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity/select_properties.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nAfter the project is created, debug it from Visual Studio to make sure the template is working. After the web app loads, stop debugging. Since we're creating a custom in-memory user store, we don't need the database so you can delete the Migrations folder out of the project's Data folder\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity/delete_migrations_folder.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nAt this point we have an ASP .NET core web app project with basic user authentication support. In the sections that follow, we will create our custom implementation.\r\n<h3>Create the \"Data Access\" class</h3>\r\n<br />\r\nSince, we're storing users in memory, we need a place to keep them. We're going to create a custom class for this. This class has nothing to do with ASP .NET Core Identity but we need a place to perform basic CRUD operations on our list of in-memory users. Create a new C# class and name it <code>InMemoryUserDataAccess.cs</code>. The full class is below to copy and paste.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class InMemoryUserDataAccess\r\n{\r\n    private List&lt;ApplicationUser&gt; _users;\r\n    public InMemoryUserDataAccess()\r\n    {\r\n        _users = new List&lt;ApplicationUser&gt;();\r\n    }\r\n    public bool CreateUser(ApplicationUser user)\r\n    {\r\n        _users.Add(user);\r\n        return true;\r\n    }\r\n\r\n    public ApplicationUser GetUserById(string id)\r\n    {\r\n        return _users.FirstOrDefault(u =&gt; u.Id == id);\r\n    }\r\n\r\n    public ApplicationUser GetByEmail(string email)\r\n    {\r\n        return _users.FirstOrDefault(u =&gt; u.NormalizedEmail == email);\r\n    }\r\n\r\n    public ApplicationUser GetUserByUsername(string username)\r\n    {\r\n       return _users.FirstOrDefault(u =&gt; u.NormalizedUserName == username);\r\n    }\r\n\r\n    public string GetNormalizedUsername(ApplicationUser user)\r\n    {\r\n        return user.NormalizedUserName;\r\n    }\r\n\r\n    public bool Update(ApplicationUser user)\r\n    {\r\n        // Since get user gets the user from the same in-memory list,\r\n        // the user parameter is the same as the object in the list, so nothing needs to be updated here.\r\n        return true;\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nNext, we need to add this to the <code>ConfigureServices</code> method in the <code>Startup</code> class for dependency injection. Since it's an in-memory list, we will use a singleton. Add <code class=\"language-csharp\">services.AddSingleton&lt;InMemoryUserDataAccess&gt;();</code>. The <code>ConfigureServices</code> method is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n\tservices.AddDbContext&lt;ApplicationDbContext&gt;(options =>\r\n\t\toptions.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\")));\r\n\r\n    services.AddSingleton&lt;InMemoryUserDataAccess&gt;();\r\n    services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;()\r\n\t\t.AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()\r\n        .AddDefaultTokenProviders();\r\n\r\n\t// Add application services.\r\n    services.AddTransient&lt;IEmailSender, EmailSender&gt;();\r\n    services.AddMvc();\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>Create Custom User Store</h3>\r\n<br />\r\nWe're finally ready to create our custom user store. The user store in ASP .NET identity can be a complex system of functionality. Luckily, this functionality is broken out into a series of interfaces so we can choose what functionality we want our user store to support. To keep it simple, we're going to implement the <code>IUserPasswordStore</code> and <code>IUserEmailStore</code> interfaces. This is enough to get us started. There are a lot of other interfaces for handling claims, phone numbers, 2 factor authentication, account lockout, etc. <a target=\"_blank\" href=\"https://docs.microsoft.com/en-us/aspnet/identity/overview/extensibility/overview-of-custom-storage-providers-for-aspnet-identity#userstore\">This microsoft doc</a> goes into a lot more detail on all the store interfaces.\r\n<br /><br />\r\nThe full implementation is below. Notice the dependency to <code>InMemoryUserDataAccess</code> we created above. I did not implement delete. I'll leave that up to you.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class InMemoryUserStore : IUserPasswordStore&lt;ApplicationUser&gt;, IUserEmailStore&lt;ApplicationUser&gt;\r\n{\r\n    private InMemoryUserDataAccess _dataAccess;\r\n    public InMemoryUserStore(InMemoryUserDataAccess da)\r\n    {\r\n        _dataAccess = da;\r\n    }\r\n\r\n    public Task&lt;IdentityResult&gt; CreateAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;IdentityResult&gt;.Run(() =&gt;\r\n        {\r\n            IdentityResult result = IdentityResult.Failed();\r\n            bool createResult = _dataAccess.CreateUser(user);\r\n\r\n            if (createResult)\r\n            {\r\n                result = IdentityResult.Success;\r\n            }\r\n\r\n            return result;\r\n        });\r\n    }\r\n\r\n    public Task&lt;IdentityResult&gt; DeleteAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n        \r\n    }\r\n\r\n    public Task&lt;ApplicationUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;ApplicationUser&gt;.Run(() =&gt;\r\n        {\r\n            return _dataAccess.GetByEmail(normalizedEmail);\r\n        });\r\n    }\r\n\r\n    public Task&lt;ApplicationUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;ApplicationUser&gt;.Run(() =&gt;\r\n        {\r\n            return _dataAccess.GetUserById(userId);\r\n        });\r\n    }\r\n\r\n    public Task&lt;ApplicationUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;ApplicationUser&gt;.Run(() =&gt;\r\n        {\r\n            return _dataAccess.GetUserByUsername(normalizedUserName);\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetEmailAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n            return Task&lt;string&gt;.Run(() =&gt;\r\n            {\r\n                return user.Email;\r\n            });\r\n    }\r\n\r\n    public Task&lt;bool&gt; GetEmailConfirmedAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;bool&gt;.Run(() =&gt;\r\n        {\r\n            return user.EmailConfirmed;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetNormalizedEmailAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.NormalizedEmail;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetNormalizedUserNameAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.NormalizedUserName;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetPasswordHashAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt; { return user.PasswordHash; });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetUserIdAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.Id;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetUserNameAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.UserName;\r\n        });\r\n    }\r\n\r\n    public Task&lt;bool&gt; HasPasswordAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;bool&gt;.Run(() =&gt; { return true; });\r\n    }\r\n\r\n\tpublic Task SetEmailAsync(ApplicationUser user, string email, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt; {\r\n            user.Email = email;\r\n        });\r\n    }\r\n\r\n    public Task SetEmailConfirmedAsync(ApplicationUser user, bool confirmed, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.EmailConfirmed = confirmed;\r\n        });\r\n    }\r\n\r\n    public Task SetNormalizedEmailAsync(ApplicationUser user, string normalizedEmail, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.NormalizedEmail = normalizedEmail;\r\n        });\r\n    }\r\n\r\n    public Task SetNormalizedUserNameAsync(ApplicationUser user, string normalizedName, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.NormalizedUserName = normalizedName;\r\n        });\r\n    }\r\n\r\n    public Task SetPasswordHashAsync(ApplicationUser user, string passwordHash, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt; { user.PasswordHash = passwordHash; });\r\n    }\r\n\r\n    public Task SetUserNameAsync(ApplicationUser user, string userName, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.UserName = userName;\r\n            user.NormalizedUserName = userName.ToUpper();\r\n        });\r\n    }\r\n\r\n    public Task&lt;IdentityResult&gt; UpdateAsync(ApplicationUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;IdentityResult&gt;.Run(() =&gt;\r\n        {\r\n            IdentityResult result = IdentityResult.Failed();\r\n            bool updateResult = _dataAccess.Update(user);\r\n\r\n            if (updateResult)\r\n            {\r\n                result = IdentityResult.Success;\r\n            }\r\n\r\n            return result;\r\n        });\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe dependency injection support in ASP .NET Core MVC makes it easy to use our implementation. We need to add another line to the <code>ConfigureServices</code> method in the <code>Startup</code> class. Add this right after the singleton for <code>InMemoryUserDataAccess</code>. <code class=\"language-csharp\">services.AddTransient&lt;IUserStore&lt;ApplicationUser&gt;, InMemoryUserStore&gt;();</code>. The complete <code>ConfigureServices</code> method is below\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n\tservices.AddDbContext&lt;ApplicationDbContext&gt;(options =>\r\n\t\toptions.UseSqlServer(Configuration.GetConnectionString(\"DefaultConnection\")));\r\n\r\n    services.AddSingleton&lt;InMemoryUserDataAccess&gt;();\r\n    services.AddTransient&lt;IUserStore&lt;ApplicationUser&gt;, InMemoryUserStore&gt;();\r\n    services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;()\r\n\t\t.AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()\r\n        .AddDefaultTokenProviders();\r\n\r\n\t// Add application services.\r\n    services.AddTransient&lt;IEmailSender, EmailSender&gt;();\r\n    services.AddMvc();\r\n}\r\n</code>\r\n</pre>\r\n<h3>Test It</h3>\r\n<br />\r\nBuild and debug the project from Visual Studio. Click the Register button in the upper right corner. Enter an email and password and confirm password and click Register. The password requirements are still the default for ASP .NET Core Identity so you will need a lowercase letter, uppercase letter, number, and special character.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity/register_user.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nIt should redirect to the home page and the Register button should be replaced with a greeting Hello &lt;email&gt;! Click the Log out link next to this greeting and it redirects to the home page with the Register and Log in buttons.\r\n<br /><br />\r\nClick login and use the email and password just created. After login, you are redirected to the homepage with the same greeting.\r\n<br /><br/>\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity/login_user.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nIf you stop debugging and restart the application, the user no longer exists because it's stored in memory.\r\n<h3>Conclusion</h3>\r\n<br />\r\nThat concludes how to setup a basic custom user store for ASP .NET Core Identity. We created a custom class implementing only the interfaces we needed and the built in dependency injection makes it easy to swap implementations. User management is a complex topic with many features available for both security and user experience. Hopefully, this is a good starting point for customizing specific features around user management in your ASP .NET Core application.","author":"Carl Layton","publishedDate":"2018-11-01T12:00:00Z","friendlyUri":"create-custom-user-store-for-aspnet-core-identity","isPublished":true,"previousPostUri":"create-custom-password-hasher-for-aspnet-core-identity","previousPostTitle":"Create Custom Password Hasher for ASP .NET Core Identity","nextPostUri":"create-formatted-text-files-with-csvhelper","nextPostTitle":"Create Formatted Text Files With csvhelper","tags":["ASP .NET Core","Authentication","csharp","Identity"]}