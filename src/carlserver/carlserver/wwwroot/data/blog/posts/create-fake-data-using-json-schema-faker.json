{"id":5,"title":"Create Fake Data Using Json Schema Faker","summary":"In this post I will look at how to create fake data using Json Schema Faker and faker.js. Json Schema Faker is a node package that uses fake data generators and a schema defined in JSON to create fake data. Any application that handles data in the JSON format can use this for testing, prototyping, or general development. I will cover how to create a json schema and how to generate mock data for it using Json Schema Faker. This tutorial assumes basic knowledge of javacsript, NodeJS, and NPM and that NodeJS and NPM are installed.","body":"In this post I will look at how to create fake data using <a target=\"_blank\" href=\"https://github.com/json-schema-faker/json-schema-faker\">Json Schema Faker</a> and <a target=\"_blank\" href=\"https://github.com/marak/Faker.js/\">faker.js</a>. Json Schema Faker is a node package that uses fake data generators and a schema defined in JSON to create fake data. Any application that handles data in the JSON format can use this for testing, prototyping, or general development. I will cover how to create a json schema and how to generate mock data for it using Json Schema Faker. This tutorial assumes basic knowledge of javacsript, NodeJS, and NPM and that NodeJS and NPM are installed.\r\n<br />\r\n<br />\r\nThe mock data will represent a list of web bookmarks. The data we want to include for each bookmark is an id, title, url, and comma dilimitted list of tags. The first thing to do is install Json Schema Faker and faker.js using npm.\r\n<pre>\r\n<code class=\"language-bash\">\r\n npm install json-schema-faker\r\n npm install faker\r\n</code>\r\n</pre>\r\n<br />\r\nThe next step is to create the javascript file that will define and save the fake data. Create a file named 'generateData.js'. First, we bring in the dependencies we need.\r\n<pre>\r\n<code class=\"language-javascript\">\r\nconst jsf = require('json-schema-faker'); // json-schema faker\r\nconst fs = require('fs'); // nodeJS file system library to read and write files\r\n</code>\r\n</pre>\r\n<br />\r\n\r\nBelow is what the final schema definition looks like. I'll go over each part in detail below.\r\n<pre>\r\n<code class=\"language-javascript\">\r\nvar bookmarksSchema = {\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n      \"bookmarks\": {\r\n        \"type\": \"array\",\r\n        \"minItems\": 3,\r\n        \"maxItems\": 5,\r\n        \"items\": {\r\n          \"type\": \"object\",\r\n          \"properties\": {\r\n            \"id\": {\r\n              \"type\": \"number\",\r\n              \"unique\": true,\r\n              \"minimum\": 1\r\n            },\r\n            \"url\": {\r\n              \"type\": \"string\",\r\n              \"faker\": \"internet.url\"\r\n            },\r\n            \"title\": {\r\n              \"type\": \"string\"\r\n            },\r\n            \"tags\": {\r\n              \"type\": \"string\",\r\n              \"faker\":\"custom.tags\"\r\n            }\r\n          },\r\n          \"required\": [\"id\", \"url\", \"title\", \"tags\"]\r\n        }\r\n      }\r\n    },\r\n    \"required\": [\"bookmarks\"]\r\n  };\r\n</code>\r\n</pre>\r\nThe first line, <code class=\"language-javascript\">var bookmarksSchema = {</code> defines a regular javascript object variable named bookmarksSchema. This gets set equal to a javascript object that contains the schema definition for the bookmarks. The first line says <code class=\"language-javascript\">\"type\": \"object\",</code>, so we're creating an object. Next, the properties of this object are listed. In this case we want 1 property named \"bookmarks\". We define bookmarks as an array that contains between 3 and 5 items. Each item within that array is also an object. Each of those objects has 4 properties, id, url, title, and tags. Finally, we say that all 4 properties are required using <code class=\"language-javascript\">\"required\": [\"id\", \"url\", \"title\", \"tags\"]</code>. To close it out we declare which properties of the schema are required. In this case we only have 1 property, bookmarks, so we make it required. That is the last line <code class=\"language-javascript\">\"required\": [\"bookmarks\"]</code>.\r\n<br />\r\n<br />\r\nEach property of the bookmark item has it's own definition to tell Json Schema Faker how to generate data for it. We want <code>id</code> to be a number, that is unique, and starts with 1. We want <code>url</code> to be a string and we pass a hint that we want it to be a string that looks like a url, not just any string. We want <code>title</code> to be a string and any string will work. Finally, we define <code>tags</code> and this is a little more interesting. We want tags to be a string but we want it to be a comma delimitted list of strings. To do this, I'm going to extend Json Schema Faker to use a custom property. This is defined in the schema definition like this <code class=\"language-javascript\">\"faker\":\"custom.tags\"</code>\r\n<br /><br />\r\nThe code that defines custom.tags is added above the bookmarksSchema variable. I'm extending Json Schema Faker by defining a custom object that contains a function named tags. I can reference the result of the funciton by calling <code>custom.tags</code> where it is needed. The function returns 3 random strings concatinated by commas. Since custom.tags is a function, it can be as complex as the developer wants. We could define a random number and have it return that many words. So some bookmarks could have 3 tags, some 2 tags, or 4 tags. This also means that any data can be faked because we could have this function do anything we want and return the result. Below is the code for extending Json Schema Faker. Place this code above the bookmarksSchema variable.\r\n<pre>\r\n<code class=\"language-javascript\">\r\njsf.extend('faker', function(){\r\n  var faker = require('faker');\r\n  faker.locale = \"en\"; // or any other language\r\n  faker.custom = {\r\n    tags: function(length) {\r\n      return faker.lorem.word() + \",\" + faker.lorem.word() + \",\" + faker.lorem.word();\r\n    }\r\n  };\r\n  return faker;\r\n});\r\n</code>\r\n</pre>\r\n<br />\r\nNow we have a javascript object that defines a JSON schema and related information to generate fake data. We pass this object into <code>jsf</code> like this <code class=\"language-javascript\">var fakeData = jsf(bookmarksSchema);</code>. Now the fake data is a javascript object defined as <code>fakeData</code>. Typically, we need to use the fake data outside where it was generated so I'm going to use the filesystem api of NodeJS to save the fake data to a file so it can be used in other applications. The code below creates a file named bookmarks.json with the fake data written to it.\r\n<pre>\r\n<code class=\"language-javascript\">\r\nfs.writeFile(\"bookmarks.json\", JSON.stringify(fakeData), function (err) {\r\n  if (err) {\r\n    return console.log(err);\r\n  } else {\r\n    console.log(\"Mock data generated.\");\r\n  }\r\n});\r\n</code>\r\n</pre>\r\n<br />\r\nThe entire generateData.js file is listed below.\r\n<pre>\r\n<code class=\"language-javascript\">\r\nconst jsf = require('json-schema-faker'); // json-schema faker\r\nconst fs = require('fs'); // nodeJS file system library to read and write files\r\n\r\njsf.extend('faker', function(){\r\n    var faker = require('faker');\r\n    faker.locale = \"en\"; // or any other language\r\n    faker.custom = {\r\n      tags: function(length) {\r\n        return faker.lorem.word() + \",\" + faker.lorem.word() + \",\" + faker.lorem.word();\r\n      }\r\n    };\r\n    return faker;\r\n  });\r\n  \r\n\r\nvar bookmarksSchema = {\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n      \"bookmarks\": {\r\n        \"type\": \"array\",\r\n        \"minItems\": 3,\r\n        \"maxItems\": 5,\r\n        \"items\": {\r\n          \"type\": \"object\",\r\n          \"properties\": {\r\n            \"id\": {\r\n              \"type\": \"number\",\r\n              \"unique\": true,\r\n              \"minimum\": 1\r\n            },\r\n            \"url\": {\r\n              \"type\": \"string\",\r\n              \"faker\": \"internet.url\"\r\n            },\r\n            \"title\": {\r\n              \"type\": \"string\"\r\n            },\r\n            \"tags\": {\r\n              \"type\": \"string\",\r\n              \"faker\":\"custom.tags\"\r\n            }\r\n          },\r\n          \"required\": [\"id\", \"url\", \"title\", \"tags\"]\r\n        }\r\n      }\r\n    },\r\n    \"required\": [\"bookmarks\"]\r\n  };\r\n\r\n  var fakeData = jsf(bookmarksSchema);\r\n  fs.writeFile(\"bookmarks.json\", JSON.stringify(fakeData), function (err) {\r\n    if (err) {\r\n      return console.log(err);\r\n    } else {\r\n      console.log(\"Mock data generated.\");\r\n    }\r\n  });\r\n</code>\r\n</pre>\r\nTo run the example locally, copy and paste the package.json file below and run <code class=\"language-bash\">npm install</code> in the terminal. This will download the required NPM dependencies and then run <code class=\"language-bash\">node generateData.js</code> to generate a json file with fake data.\r\n<pre>\r\n<code class=\"language-json\">\r\n{\r\n  \"name\": \"json-schema-faker-example\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"\",\r\n  \"author\": \"Carl Layton\",\r\n  \"license\": \"MIT\",\r\n  \"dependencies\": {\r\n    \"faker\": \"^4.1.0\",\r\n    \"json-schema-faker\": \"^0.5.0-rc13\"\r\n  }\r\n}\r\n</code>\r\n</pre>\r\n\r\n<br />\r\nIn conclusion, creating fake data with Json Schema Faker doesn't take much effort or code. The majority of the work is done in defining the schema. <a target=\"_blank\" href=\"https://github.com/marak/Faker.js/\">faker.js</a> supports a lot of different kinds of fake data out of the box and I suggest reviewing the documentation to see what other kinds of data can be easily faked. It is a great way to get fake data for UI prototyping or front end web development before an API is created.","author":"Carl Layton","publishedDate":"2018-03-25T16:30:00Z","friendlyUri":"create-fake-data-using-json-schema-faker","isPublished":true,"previousPostUri":"angularjs-route-resolve-failed-promise-example","previousPostTitle":"AngularJS Route Resolve Failed Promise Example","nextPostUri":"applying-the-strategy-pattern-to-vary-data-access-methods-in-csharp","nextPostTitle":"Applying The Strategy Pattern To Vary Data Access Methods In C#","tags":["javascript","json","mock data"]}