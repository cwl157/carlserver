{"id":13,"title":"Create Formatted Text Files With csvhelper","summary":"In this post, I will show some examples for reading and writing text files using csvhelper. Csvhelper is a simple and fast library primarily used for writing csv files. Additionally, it can be configured to use any character as a delimiter. It is available via NuGet. I have used csvhelper in a number of projects for data export features or saving preferences, etc.","body":"This post is part of the <a href=\"https://crosscuttingconcerns.com/The-Second-Annual-C-Advent\">2018 C# advent</a>. Be sure to check out the other great posts as well. In this post, I will show some examples for reading and writing text files using <a target=\"_blank\" href=\"https://joshclose.github.io/CsvHelper/\">csvhelper.</a> Csvhelper is a simple and fast library primarily used for writing csv files and implements <a target=\"_blank\" href=\"https://tools.ietf.org/html/rfc4180\">RFC 4180</a>. Additionally, it can be configured to use any character as a delimiter. It is available via <a target=\"_blank\" href=\"https://www.nuget.org/packages/CsvHelper/\">NuGet</a>. I have used csvhelper in a number of projects for data export features or saving preferences, etc.\r\n<br /><br />\r\nI created a sample command line application to highlight reading files, writing files, and a couple advanced configuration options. The application allows the user to manage a book collection including title, author, and number of pages. I won’t be going over every line but the entire project is available at <a target=\"_blank\" href=\"https://github.com/cwl157/csvhelper-examples\">this GitHub repository.</a> The app requires .NET Framework 4.7.1. Below is a screenshot of the main menu.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-formatted-text-files-with-csvhelper/main_menu.png\" style=\"width:75%;\" />\r\n<br /><br />\r\n<h3>Reading files</h3>\r\n<br />\r\nThe sample application includes a <code>data</code> folder that contains a couple of test files. Let’s import the csv file. I’m going to select option 3 and follow the prompts. Notice, one of the prompts asks for the delimiter to use. In this example, I’m going to stick to csv files but the <code>data</code> folder contains a pipe ( | ) delimited file as well.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-formatted-text-files-with-csvhelper/import_full.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nSelecting option 2 will display the list of books we just imported.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-formatted-text-files-with-csvhelper/full_import_list.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nNow that we have successfully imported the books, we're going to take a closer look at the read functionality of the library. Also, notice \"total pages\" listed in the screenshot above is correct because page length was converted to an integer when csvhelper read the file. The full method is below. The <code>GetRecords</code> method of the <code>CsvReader</code> class does the reading and parsing. The example below uses the generic version of this method but there are overloads for a type parameter or for a dynamic object. There is also a method called <code>EnumerateRecords</code>. This will enumerate through the records and populate the given record instead of getting all results in one big list. Additionally, a configuration option is used to specify the character to use as a delimiter. Finally, there is a custom map class that I'll explain later in the post. The delimiter was the last input provided above and can be changed. Try running the import again and choose the <code>Books.pipe</code> file and specify <code>|</code> as the delimiter.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nprivate static List&lt;Book&gt; Read(string filePath, string delimiter)\r\n{\r\n    List&lt;Book&gt; results = new List&lt;Book&gt;();\r\n    try\r\n    {\r\n        using (StreamReader reader = File.OpenText(filePath))\r\n        {\r\n            CsvReader csv = new CsvReader(reader);\r\n            csv.Configuration.Delimiter = delimiter;\r\n            csv.Configuration.RegisterClassMap&lt;BookMap&gt;();\r\n            IEnumerable&lt;Book&gt; records = csv.GetRecords&lt;Book&gt;();\r\n            results = records.ToList();\r\n        }\r\n    }\r\n    catch (Exception e)\r\n    {\r\n        Console.WriteLine(e.Message);\r\n    }\r\n    return results;\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nIt is also possible to only import a subset of records. To do this, we use some other methods of the <code>CsvReader</code> class, specifically, <code>Read()</code> and <code>ReadHeader()</code>. According to the <a target=\"_blank\" href=\"https://joshclose.github.io/CsvHelper/reading#reading-records\">documentation</a>, <code>ReadHeader()</code> must be called after the first call to <code>Read()</code> and that allows you to loop through the records and read each one. There is also a <code>ReadAsync()</code> method too. Below is the code for importing only a certain number of books. Using <code>Read()</code> and <code>ReadHeader()</code> we can get each row individually. It is option 4 in the demo app.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nprivate static List<Book> Read(string filePath, string delimiter, string numberOfRecords)\r\n{\r\n    int count = 0;\r\n    List&lt;Book&gt; results = new List&lt;Book&gt;();\r\n    if (!int.TryParse(numberOfRecords, out count))\r\n    {\r\n        Console.WriteLine(\"Not a valid number\");\r\n        return results;\r\n    }\r\n    // Read from csv record by record up to count\r\n    try\r\n    {\r\n        using (StreamReader reader = File.OpenText(filePath))\r\n        {\r\n            CsvReader csv = new CsvReader(reader);\r\n            csv.Configuration.Delimiter = delimiter;\r\n            csv.Configuration.RegisterClassMap&lt;BookMap&gt;();\r\n            csv.Read();\r\n            csv.ReadHeader();\r\n            for (int i = 0; i < count; i++)\r\n            {\r\n                if (csv.Read())\r\n                {\r\n                    Book record = csv.GetRecord&lt;Book&gt;();\r\n                    results.Add(record);\r\n                }\r\n            }\r\n        }\r\n     }\r\n     catch (Exception e)\r\n     {\r\n         Console.WriteLine(e.Message);\r\n     }\r\n\r\n      return results;\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>Writing files</h3>\r\n<br />\r\nWe're now going to look at writing files. First, choose option 1 in the demo app and follow the prompts to add your favorite book.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-formatted-text-files-with-csvhelper/add_book.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nSelect option 2 to see our new book added to the list\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-formatted-text-files-with-csvhelper/book_list_with_add.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nFinally, choose option 6 and follow the prompts to export the full book list.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-formatted-text-files-with-csvhelper/full_export.png\" style=\"width:75%;\" />\r\n<br /><br />\r\nThere will be a csv file created with the exported books. The export method is below. This time we need an instance of <code>CsvWriter</code>. Like reading, writing can also specify a different delimiter. The <code>WriteRecords</code> method writes all the books to the file. It is also possible to write the header and only write a certain number of records to the file. I'm not going to show that method here but the application does have an example of it with option 7.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nprivate static void Write(List&lt;Book&gt; books, string filePath, string delimiter)\r\n{\r\n    try\r\n    {\r\n        using (StreamWriter writer = File.CreateText(filePath))\r\n        {\r\n            var csv = new CsvWriter(writer);\r\n            csv.Configuration.Delimiter = delimiter;\r\n            csv.WriteRecords(books);\r\n        }\r\n    }\r\n    catch (Exception e)\r\n    {\r\n        Console.WriteLine(e.Message);\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>Advanced Configuration And Features</h3>\r\n<br />\r\nThere are a number of advanced configuration options and features. Remember, when reading, we registered a map? This allows us to provide custom field mapping or custom logic like validation. The demo app contains custom validation to make sure the length of each book is greater than 0. If the validation returns false a <code>ValidationException</code> is thrown. The custom map class must inherit from the generic <code>ClassMap</code> class. My implementation is below. Notice, how I call <code>AutoMap()</code> first. This allows me to use the default map and then add custom validation logic to it so I only need to define the parts I want. To test this, modify the csv file so one of the records contains a length less than or equal to 0 and a <code>ValidationException</code> will be thrown on import.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic sealed class BookMap : ClassMap&lt;Book&gt;\r\n{\r\n    public BookMap()\r\n    {\r\n        AutoMap();\r\n        Map(m =&gt; m.Length).Validate(field =&gt;\r\n        {\r\n            int l;\r\n            int.TryParse(field, out l);\r\n            if (l &gt; 0)\r\n            {\r\n               return true;\r\n            }\r\n            return false;\r\n        });\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nAnother feature of csvHelper is to sanitize fields to prevent injection attacks via a csv file. Many csv files are opened in third party applications, like Excel. If one of the fields starts with an '=' this field will be interpreted as a formula by excel and could take advantage of a vulnerability. To prevent this, any field that starts with '=', '@', '+', or '-' is prepended with a '\\t' character. Through configuration options, this list can be modified, and the escape character can be changed. It's also possible to turn off sanitation all together but it is nice to know it does this out of the box. It is also possible to read individual fields. The demo application has an example of this. Option 5 will only import the titles. There are many more settings available, such as using quotes, identifying comment lines in the file, using custom type converters, and specifying different encodings, just to name a few. The <a target=\"_blank\" href=\"https://joshclose.github.io/CsvHelper/\">csvhelper website</a> has more documentation on what we went over here and additional features that I did not cover.\r\n<br /><br />\r\n<h3>Conclusion</h3>\r\n<br />\r\nIn conclusion, csvhelper is a feature-rich library for reading and writing, csv files, or any type of delimited text file. It is easy to get started with basic reading and writing but it is also possible to read and write parts of files or individual fields, and setup advanced configurations based on your needs. I hope this post and sample application are a good reference for the basic features of this library. The entire sample application is available at <a target=\"_blank\" href=\"https://github.com/cwl157/csvhelper-examples\">this github repository.</a> For more information on csvhelper and where to get it, <a target=\"_blank\" href=\"https://joshclose.github.io/CsvHelper/\">visit the csvhelper homepage.</a> Finally, be sure to check out the rest of the posts in this year's <a href=\"https://crosscuttingconcerns.com/The-Second-Annual-C-Advent\">C# Advent.</a>","author":"Carl Layton","publishedDate":"2018-12-08T06:00:00Z","friendlyUri":"create-formatted-text-files-with-csvhelper","isPublished":true,"previousPostUri":"create-custom-user-store-for-aspnet-core-identity","previousPostTitle":"Create Custom User Store for ASP .NET Core Identity","nextPostUri":null,"nextPostTitle":null,"tags":["csharp"]}