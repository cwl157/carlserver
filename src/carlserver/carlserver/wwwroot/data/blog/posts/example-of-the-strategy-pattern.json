{"id":21,"title":"Example of the Strategy Pattern","summary":"In this post I explain the strategy design pattern and show an example of applying it to import data from different data sources. The strategy pattern is a behavioral design pattern that allows different implementations to be used interchangably at runtime. An application can select the appropriate method to perform a task. The example application lets the user import music data from a csv file source or json file source. Depending on the file type, the import strategy is chosen.","body":"In this post I explain the strategy design pattern and show an example of applying it to import data from different data sources. The strategy pattern is a behavioral design pattern that allows different implementations to be used interchangeably at runtime. An application can select the appropriate method to perform a task.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/example-of-the-strategy-pattern/StrategyPatternDiagram.png\" alt-text=\"strategy pattern diagram\" width=\"75%\" height=\"75%\" />\r\n<br /><br />\r\nThe example application lets the user import music data from a csv file source or json file source. Depending on the file type, the import strategy is chosen. The example application is part of my <a target=\"_blank\" href=\"https://github.com/cwl157/design-patterns\">design patterns repository on GitHub.</a> It requires <a target=\"_blank\" href=\"https://visualstudio.microsoft.com/downloads/\">Visual Studio 2019</a> and <a target=\"_blank\" href=\"https://dotnet.microsoft.com/download\">dotnet core 3.1.</a>\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/example-of-the-strategy-pattern/app.PNG\" alt-text=\"strategy pattern diagram\" width=\"50%\" height=\"50%\" />\r\n<br />\r\n<h3>Implementing the Pattern</h3>\r\n<br />\r\nTo implement the strategy pattern we need an interface, a couple of implementations of that interface, a data object to store the imported data and a simple user interface. The object to store the imported album data is called <code>Album</code> and the code is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class Album\r\n{\r\n    public string Artist { get; set; }\r\n    public string Title { get; set; }\r\n    public int NumberOfTracks { get; set; }\r\n    public int ReleaseYear { get; set; }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe interface contains one method to import a collection of albums.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic interface IImportStrategy\r\n{\r\n    IEnumerable&lt;Album&gt; ImportAlbums(string filePath);\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThere are two implementations of the interface. One for csv formatted files and one for json formatted files. Both are below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class CsvStrategy : IImportStrategy\r\n{\r\n    public IEnumerable&lt;Album&gt; ImportAlbums(string filePath)\r\n    {\r\n        string[] lines = File.ReadAllLines(filePath);\r\n        List&lt;Album&gt; result = new List&lt;Album&gt;();\r\n        for (int i = 1; i &lt; lines.Length; i++)\r\n        {\r\n            string l = lines[i];\r\n            string[] parsedLine = l.Split(',');\r\n            result.Add(new Album\r\n            {\r\n                Artist = parsedLine[0],\r\n                Title = parsedLine[1],\r\n                ReleaseYear = int.Parse(parsedLine[2]),\r\n                NumberOfTracks = int.Parse(parsedLine[3])\r\n           });\r\n        }\r\n\t\t\r\n        return result;\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class JsonStrategy : IImportStrategy\r\n{\r\n    public IEnumerable&lt;Album&gt; ImportAlbums(string filePath)\r\n    {\r\n        JsonSerializerOptions options = new JsonSerializerOptions()\r\n        {\r\n            PropertyNameCaseInsensitive = true\r\n        };\r\n        string content = File.ReadAllText(filePath);\r\n        List&lt;Album&gt; result = JsonSerializer.Deserialize&lt;List&lt;Album&gt;&gt;(content, options);\r\n        return result;\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe code above is the basis of the pattern, an interface that defines a method and multiple implementations of that method. The calling code can decide which strategy it needs to use and isn't tied to one specific implementation. We're also going to create a separate class whose task it is to pick which strategy to use. This is a static class called <code>ImportStrategyPicker.</code> It contains one method that takes the fileType and returns the correct <code>IImportStrategy</code> implementation.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic static class ImportStrategyPicker\r\n{\r\n    public static IImportStrategy Select(string fileType)\r\n    {\r\n        if (fileType == \".csv\")\r\n        {\r\n            return new CsvStrategy();\r\n        }\r\n        else if (fileType == \".json\")\r\n        {\r\n            return new JsonStrategy();\r\n        }\r\n\r\n        throw new ApplicationException(\"No strategy found for file type: \" + fileType);\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThis can be called directly from the client code that executes the strategy. This would mean every time a strategy is required, the picker would need to be called first to find one. Sometimes finding the correct strategy can be a lot of work and it makes sense to store the strategy in an object so it can be used multiple times. This example contains the <code>MusicManager</code> class for this purpose. It contains the Strategy used for import and the list of albums imported.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class MusicManager\r\n{\r\n    public List&lt;Album&gt; Albums { get; private set; }\r\n    public IImportStrategy Importer { get; set; }\r\n\r\n    public MusicManager()\r\n    {\r\n        Albums = new List&lt;Album&gt;();\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe code to pick a strategy based on file type is below. I'm not going to show the entire main method, just the parts that selects and executes the strategy. This can be used in multiple ways in applications.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nConsole.Write(\"File path (csv or json): \");\r\nstring filepath = Console.ReadLine();\r\nstring extension = Path.GetExtension(filepath);\r\nmanager.Importer = ImportStrategyPicker.Select(extension.ToLower());\r\nvar albums = manager.Importer.ImportAlbums(filepath);\r\n</code>\r\n</pre>\r\n<br />\r\nAt this point, the albums are imported from the specified file using either the csv or json import strategy. The full sample application source code is available on <a target=\"_blank\" href=\"https://github.com/cwl157/design-patterns\">GitHub.</a> It also includes sample data files.\r\n<br />\r\n<h3>Conclusion</h3>\r\nIn conclusion, we looked at the strategy pattern in this post. The strategy pattern allows an application to pick the appropriate strategy at runtime to perform a task. The example application can import a list of albums from either a csv or json file source.","author":"Carl Layton","publishedDate":"2020-04-05T17:30:00Z","friendlyUri":"example-of-the-strategy-pattern","isPublished":true,"previousPostUri":"create-custom-user-store-for-aspnet-core-identity-v3-update","previousPostTitle":"Create Custom User Store for ASP .NET Core Identity - .NET Core 3 Update","nextPostUri":"create-a-music-player-in-wpf-using-the-mvvm-pattern","nextPostTitle":"Create a Music Player in WPF Using the MVVM Pattern","isFeatured":true,"tags":["dotnet","csharp","Design patterns"]}