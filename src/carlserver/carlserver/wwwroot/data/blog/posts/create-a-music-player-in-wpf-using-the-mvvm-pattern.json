{"id":22,"title":"Create a Music Player in WPF Using the MVVM Pattern","summary":"In this post, I examine a WPF application to play mp3 music. I will show how WPF can utilize the MVVM pattern to make code more testable. At the end of this post, you will have an understanding of the MVVM pattern and how to apply it to a WPF application with unit tests. The application is written in .NET core 3.1 and Visual Studio 2019.","body":"This post is part of the <a href=\"https://www.csadvent.christmas\">2020 C# Advent Calendar.</a> Please check out all the great posts. In this post, I examine a WPF application to play mp3 music. I will show how WPF can utilize the MVVM pattern to make code more testable. At the end of this post, you will have an understanding of the MVVM pattern and how to apply it to a WPF application with unit tests to test the state of the application after each user action. The application was written using <a href=\"https://dotnet.microsoft.com/download\">.NET core 3.1</a> and <a href=\"https://visualstudio.microsoft.com/downloads/\">Visual Studio 2019</a>. The full source code can be found in <a href=\"https://github.com/cwl157/music-player\">GitHub.</a>\r\n<br /><br />\r\n<h3>The MVVM Pattern</h3>\r\nMVVM stands for Model, View, View Model. It is a structural design pattern that allows for the separation of code into 3 groups. The view is the UI. The model is the business logic. The view model sits between the view and the model and is responsible for translating data back and forth between them. The key component to this pattern is the use of data binding. The data binder is responsible for synchronizing data between the view and view model. Two way data binding will update data both ways. If the data changes in the view, the view model is updated to reflect the changes and if data is changed in the view model, the view is updated. Typically, there is also a collection of services, which contain logic to help the model carry out it's functions like data persistence.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/create-a-music-player-in-wpf-using-the-mvvm-pattern/mvvm-1.png\" alt-text=\"outbox pattern diagram\" width=\"33%\" height=\"33%\" />\r\n<br /><br />\r\nTwo big reasons to use the MVVM pattern are separation of concerns and unit testing. By keeping the view logic in a view model, the UI that makes up the view can be largely declaritive. It is also easier to unit test the state of the view model when it's decoupled from the code behind of the view. I'll show some unit tests for this application later in the post.\r\n<br /><br />\r\n<h3>The Application</h3>\r\nThe application is a WPF application to play mp3s. It allows the user to specify a folder containing the mp3 files and loads them into a song list to be played. Simple playback controls are provided as well as album art and lyrics, if available in the meta data. To keep the application simple there is only one view and one view model. There is no support for a media library. The song list is only driven by the files in the provided folder. Features like that might be fun to add later. The application uses <a href=\"https://www.nuget.org/packages/TagLibSharp/\">TagLib Sharp</a> to read meta tags from the mp3 files.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/create-a-music-player-in-wpf-using-the-mvvm-pattern/music-player.png\" alt-text=\"outbox pattern diagram\" width=\"75%\" height=\"75%\" />\r\n<br /><br />\r\n<h3>The Model</h3>\r\nThe application contains two model classes. The first class holds the properties of a Song. The <code>Song</code> class is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class Song\r\n{\r\n    public string Artist { get; set; }\r\n    public string Album { get; set; }\r\n    public string Title { get; set; }\r\n    public string FilePath { get; set; }\r\n    public int TrackNumber { get; set; }\r\n    public TimeSpan Duration { get; set; }\r\n    public string DisplayDuration\r\n    {\r\n        get\r\n        {\r\n            return Duration.ToString(\"mm\\\\:ss\");\r\n        }\r\n    }\r\n    public string Lyrics { get; set; }\r\n    public BitmapImage AlbumArt { get; set; }\r\n    public string Year { get; set; } \r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nYou probably noticed the <code>DisplayDuration</code> property above. The MVVM pattern allows for the separation of business logic from view logic and this property is clearly for the view. I considered this but didn't think it made sense to make a view model for the Song and convert between model and view model for one property. Patterns are meant to be adapted for each situation and this made the most sense in this situation. It is common to have a model whose properties are represented differently from the view model because data that needs business logic applied is often different from data that needs to be displayed.\r\n<br /><br />\r\nThe model also contains a <code>SongCollection</code> class that holds a collection of songs that make up the list of songs to be played. The class is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class SongCollection\r\n{\r\n    private readonly IQueueLoader _loader;\r\n\r\n    public ObservableCollection&lt;Song&gt; SongList { get; }\r\n\r\n    public SongCollection(IQueueLoader ql)\r\n    {\r\n        SongList = new ObservableCollection&lt;Song&gt;();\r\n        _loader = ql;\r\n    }\r\n\r\n    public void Load(string filepath)\r\n    {\r\n       var songs = _loader.Load(filepath);\r\n\r\n        foreach (Song s in songs)\r\n        {\r\n            SongList.Add(s);\r\n        }\r\n    }\r\n\r\n    public double TotalSeconds()\r\n    {\r\n        return SongList.Sum(s =&gt; s.Duration.TotalSeconds);\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>Services</h3>\r\nThe application contains one service called <code>FileQueueLoader</code> that implements the <code>IQueueLoader</code> interface. This service loads the songs into the song list from the provided folder path. The interface allows the queue loader implementation to be stubbed for unit testing. I did not include the implementation of these here as they are not directly part of the model, view, or view model but the source code can be found <a target=\"_blank\" href=\"https://github.com/cwl157/music-player/tree/master/src/MusicPlayer/Services\">in the GitHub repository.</a>\r\n<br /><br />\r\n<h3>The View</h3>\r\nThe view is (mostly) made from XAML. It uses standard controls like buttons, text boxes, etc. I did not include all of the XAML code here but included an example of the label that displays the currently playing track number and song title. It is possible to fit all the logic of this application into the code behind of the XAML. However, that makes it harder to test and maintain. This is where the view model comes in. The <code>DataContext</code> of the view is set to an instance of the view model. This allows public properties of the view model to be <i>binded</i> to view elements and the view is aware of what property it is referring to. The constructor of the view is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nprivate MainWindowViewModel _vm;\r\npublic MainWindow()\r\n{\r\n    InitializeComponent();\r\n    Player.LoadedBehavior = MediaState.Manual;\r\n    IQueueLoader ql = new FileQueueLoader();\r\n    SongCollection collection = new SongCollection(ql);\r\n    _vm = new MainWindowViewModel(this, collection);\r\n    DataContext = _vm;\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<i>Data binding</i> is used to bind properties from the view model to elements in the view. Below is an example of the view element that displays the track and title of the currently playing song. The <code>Content</code> property is <i>binded</i> to the <code>TrackTitleInfo</code> property of the view model. I'll explain how the view is notified of the property change when I look at the view model in the next section.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/create-a-music-player-in-wpf-using-the-mvvm-pattern/now-playing-label.png\" alt-text=\"outbox pattern diagram\" width=\"50%\" height=\"50%\" />\r\n<pre>\r\n<code class=\"language-xml\">\r\n&lt;Label\r\n\tx:Name=\"NowPlayingLabel\"\r\n\tContent=\"{Binding TrackTitleInfo}\"\r\n\tGrid.Column=\"2\"\r\n\tHorizontalAlignment=\"Left\"\r\n\tMargin=\"349,61,0,0\"\r\n\tVerticalAlignment=\"Top\"\r\n\tFontSize=\"14\"\r\n\tWidth=\"358\" Height=\"28\"/&gt;\r\n</code>\r\n</pre>\r\n<br />\r\nActions the user can execute through the UI, like button clicks, also use <i>data binding</i> on a view element's <code>Command</code> property. The <code>Add to Queue</code> button is below with the <code>AddToQueueCommand</code> command binded to the <code>Command</code> property of the button element. I will show how the command is executed when invoked via a button click in the next section.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/create-a-music-player-in-wpf-using-the-mvvm-pattern/add-to-queue.png\" alt-text=\"add to queue screenshot\" />\r\n<pre>\r\n<code class=\"language-xml\">\r\n&lt;Button\r\n\tx:Name=\"AddToQueueBtn\"\r\n\tCommand=\"{Binding AddToQueueCommand}\"\r\n\tContent=\"Add to Queue\"\r\n\tHorizontalAlignment=\"Left\"\r\n\tMargin=\"518,12,0,0\"\r\n\tVerticalAlignment=\"Top\"\r\n\tGrid.Column=\"2\"\r\n\tWidth=\"96\"/&gt;\r\n</code>\r\n</pre>\r\n<br />\r\nOne challenge I had was directly controlling the <code>MediaElement</code>, the control that handles playback, from the view model. To make this possible without passing the <code>MediaElement</code> instance directly to the view model, I created an interface that exposes methods for playback called <code>IMusicPlayer</code>. The code behind of the view implements this interface and calls the appropriate method against the actual <code>MediaElement</code> instance. The instance of <code>IMusicPlayer</code> is passed to the view model instead of the <code>MediaElement</code> directly. This indirection keeps any UI specific controls out of the view model and allows for <code>IMusicPlayer</code> to be stubbed or mocked for unit testing. The interface and implementation are below. In this example, the implementation is part of the view code behind. The key is to keep that implementation as small as possible and put additional logic for handling playback in the view model.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nIMusicPlayer.cs\r\npublic interface IMusicPlayer\r\n{\r\n    void Play(Uri filePath);\r\n    void Play();\r\n    void Pause();\r\n    void Stop();\r\n    void FastForward(double milliseconds);\r\n    void Rewind(double milliseconds);\r\n    bool IsDone();\r\n}\r\n\r\nMainWindow.xaml.cs\r\npublic void Play(Uri filePath)\r\n{\r\n    Player.Source = filePath;\r\n    Player.Play();\r\n}\r\n\r\npublic void Play()\r\n{\r\n    Player.Play();\r\n}\r\n\r\npublic void Pause()\r\n{\r\n    Player.Pause();\r\n}\r\n\r\npublic void Stop()\r\n{\r\n    Player.Stop();\r\n    \r\n}\r\n\r\npublic void FastForward(double milliseconds)\r\n{\r\n    Player.Position += TimeSpan.FromMilliseconds(milliseconds);\r\n}\r\n\r\npublic void Rewind(double milliseconds)\r\n{\r\n    Player.Position -= TimeSpan.FromMilliseconds(milliseconds);\r\n}\r\n\r\npublic bool IsDone()\r\n{\r\n    return Player.Position &gt;= Player.NaturalDuration;\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nAnother challenge I had was wiring up events in the view that belong to items dynamically generated like each song in the list. This is another place where code behind can help. In this case, I want a double click handler on each item in the song list, so when a song is double clicked, it starts playing. I added the event handler to the code behind of the view and it calls the view model to execute the logic.\r\n<br /><br />\r\n<img src=\"/data/blog/posts/img/create-a-music-player-in-wpf-using-the-mvvm-pattern/song-list.png\" alt-text=\"add to queue screenshot\" />\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic void ListViewItem_MouseDoubleClick(object sender, MouseEventArgs e)\r\n{\r\n     _vm.PlaySong.Execute(null);\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>View Model</h3>\r\nThe final piece is the view model. The view model contains everything needed to drive the view. This includes properties displayed in the view and the commands that are executed by the user through the UI. This application only has one view so the view model is named <code>MainWindowViewModel</code>. If there were multiple views, each would have a corresponding view model and the name should match the view that uses it. The view model can be broken down into 4 sections private fields, properties, commands, and command actions. \r\n<br /><br />\r\nThere are a few private fields the view model uses to manage it's state. The biggest are timers to manage the playing progress bar and advancing to the next song in the list when the current one finishes. I'm not going to go into detail on the timers but they are local to the view model. It also contains an instance of <code>IMusicPlayer</code> to control music playback and a <code>SongCollection</code> which is the song list to be played.\r\n<br /><br />\r\nThe view model also contains a number of properties that are bound to the view to display current playing progress and details of the song being played. The view model implements the <code>INotifyPropertyChanged</code> interface so the view is notified to update when a property changes. The <code>SongList</code> property is an <code>ObservableCollection</code> which already implements this interface as well as, <code>INotifyCollectionChanged</code>, the interface that notifies listeners when the collection changes. When a property value changes it needs to invoke the <code>PropertyChanged</code> event for the property that was changed. For example, when a new song starts playing, the <code>TrackTitleInfo</code> property is updated which calls <code>PropertyChanged</code> and the view gets updated to reflect the changes. The <code>PropertyChanged</code> event can be implemented with one line, <code class=\"language-csharp\">public event PropertyChangedEventHandler PropertyChanged = delegate { };</code>. Below is the code for the <code>TrackTitleInfo</code> property. The other properties follow the same pattern.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nprivate string _trackTitleInfo;\r\npublic string TrackTitleInfo\r\n{\r\n    get { return _trackTitleInfo; }\r\n    set\r\n    {\r\n        _trackTitleInfo = value;\r\n        PropertyChanged(this, new PropertyChangedEventArgs(\"TrackTitleInfo\"));\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\nThe view model contains the commands for each action the user can execute from the UI. Command execution uses <i>another</i> pattern called the <i>command pattern</i>. <a href=\"https://en.wikipedia.org/wiki/Command_pattern\">Wikipedia has an overview of the command pattern.</a> Basically, there is a command handler that implements the <code>ICommand</code> interface. This takes an <code>Action</code> to be executed and determines if the command is enabled or not. A generic implementation that works for this application is the <a href=\"https://github.com/cwl157/music-player/blob/master/src/MusicPlayer/Infrastructure/CommandHandler.cs\">CommandHandler class.</a>\r\n<br /><br />\r\nBelow is a list of the constructors for all commands in the view model.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nAddToQueueCommand = new CommandHandler(() =&gt; AddToQueueAction(), () =&gt; true);\r\nClearQueueCommand = new CommandHandler(() =&gt; ClearQueueAction(), () =&gt; true);\r\nPlaySong = new CommandHandler(() =&gt; PlaySongAction(), () =&gt; true);\r\nPauseSong = new CommandHandler(() =&gt; PauseSongAction(), () =&gt; true);\r\nStopSong = new CommandHandler(() =&gt; StopSongAction(), () =&gt; true);\r\nFastForwardCommand = new CommandHandler(() =&gt; FastForwardAction(), () =&gt; true);\r\nRewindCommand = new CommandHandler(() =&gt; RewindAction(), () =&gt; true);\r\n</code>\r\n</pre>\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-a-music-player-in-wpf-using-the-mvvm-pattern/user-command-action.png\" alt-text=\"outbox pattern diagram\" width=\"50%\" height=\"50%\" />\r\n<br /><br />\r\nIn the view section above, I pointed out the command to add songs to the song list. This is implemented using the <code>AddToQueueCommand</code> command and <code>AddToQueueAction</code> action. The user clicks the button, it executes the command bounded to it, in this case <code>AddToQueueCommand</code>, and the command executes the <code>action</code> assigned to this command, in this case <code>AddToQueueAction</code>. The action contains the logic that needs to happen when the command is executed and this is a regular C# method in the view model. The implementation of the <code>AddToQueueAction</code> is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\nprivate void AddToQueueAction()\r\n{\r\n    _currentQueue.Load(QueueFilePath);\r\n\r\n    if (_currentQueue.SongList.Count &gt; 0)\r\n    {\r\n        double queueDuration = _currentQueue.TotalSeconds();\r\n        string format = \"hh\\\\:mm\\\\:ss\";\r\n        if (queueDuration &lt; 3600)\r\n        {\r\n            format = \"mm\\\\:ss\";\r\n        }\r\n        TimeSpan totalDuration = TimeSpan.FromSeconds(queueDuration);\r\n        QueueInfo = _currentQueue.SongList.Count + \" songs - \" + totalDuration.ToString(format);\r\n    }\r\n}\r\n</code>\r\n</pre> \r\n<br />\r\n<h3>Unit Tests</h3>\r\nEach command of the view model can be unit tested. These can be found in the <code>MusicPlayer.Tests</code> project. It contains stub implementations of the <code>IMusicPlayer</code> and <code>IQueueLoader</code> interfaces and a unit test for each command defined in the view model. The test executes the command and then verifies the state of the view model. I won't show every test here but highlight the <code>PlayCommand</code> test as an example.\r\n<pre>\r\n<code class=\"language-csharp\">\r\n[Test]\r\npublic void PlayCommand_Test()\r\n{\r\n\r\n    IMusicPlayer mp = new MusicPlayerStub();\r\n    IQueueLoader ql = new QueueLoaderStub();\r\n    SongCollection collection = new SongCollection(ql);\r\n    MainWindowViewModel vm = new MainWindowViewModel(mp, collection);\r\n\r\n    vm.AddToQueueCommand.Execute(null);\r\n\r\n    vm.SelectedIndex = 0;\r\n    vm.SelectedSong = vm.SongList[vm.SelectedIndex];\r\n    vm.PlayingSong = vm.SongList[1];\r\n    vm.PlaySong.Execute(null);\r\n\r\n    // Assert playing song properties match selected song properties\r\n    Assert.AreEqual(\"Test\", vm.PlayingSong.Artist);\r\n    Assert.AreEqual(\"Title\", vm.PlayingSong.Title);\r\n    Assert.AreEqual(\"Test Album\", vm.PlayingSong.Album);\r\n    // Assert viewmodel state\r\n    Assert.AreEqual(\"Test - Test Album [2018]\", vm.ArtistAlbumInfo);\r\n    Assert.AreEqual(\"1. Title\", vm.TrackTitleInfo);\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>MVVM Frameworks</h3>\r\nThere are a number of MVVM frameworks for WPF that include more commands and more sophisticated data binding scenarios. These would help address the challenges around events and controls I detailed above. They also allow for even more separation of view from view model. Since this is my first WPF application, I didn't want to use a framework. A couple popular ones are <a href=\"https://prismlibrary.com/docs/\">prism</a> and <a href=\"http://www.mvvmlight.net/\">MVVM Light.</a> Bigger and more sophisticated WPF applications could benefit from a framework.\r\n<br />\r\n<h3>Conclusion</h3>\r\nIn conclusion, the MVVM pattern can be used with a WPF application to separate the view from logic and make the application more testable. MVVM stands for Model, View, View Model. It is a structural design pattern that allows for the separation of code into 3 groups. The view is the UI. The model is the business logic. The view model sits between the view and the model and is responsible for translating data back and forth between them. I went over a WPF application to play MP3s that uses this pattern and showed how the view and view model are connected using model binding and commands. I hope you found this post helpful and enjoy those holiday songs this time of year. The full source code <a href=\"https://github.com/cwl157/music-player\">is available in GitHub.</a> If you would like to download the music player, it is available under the releases section. Finally, head over to the <a href=\"https://www.csadvent.christmas/\">C# Advent Calendar 2020</a> to see all the great posts this year!","author":"Carl Layton","publishedDate":"2020-10-04T12:00:00Z","friendlyUri":"create-a-music-player-in-wpf-using-the-mvvm-pattern","isPublished":true,"previousPostUri":"example-of-the-strategy-pattern","previousPostTitle":"Example of the Strategy Pattern","nextPostUri":null,"nextPostTitle":null,"isFeatured":true,"tags":["dotnet","wpf","design patterns"]}