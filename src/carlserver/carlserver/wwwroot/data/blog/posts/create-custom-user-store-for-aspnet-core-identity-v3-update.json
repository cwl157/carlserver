{"id":20,"title":"Create Custom User Store for ASP .NET Core Identity - .NET Core 3 Update","summary":"This post is an update to my previous post on how to create a custom user store in dotnet core 2. It contains updated code for working with dotnet core 3.x, the Visual Studio 2019 MVC project template, and updated screenshots. The end result is the same, an in-memory user store to plug into the ASP .NET Core Identity system.","body":"<span style=\"font-style: italic\">This post is an update to my previous post on how to create a custom user store in dotnet core 2. It contains updated code for working with dotnet core 3.x, the Visual Studio 2019 MVC project template, and updated screenshots. The end result is the same, an in-memory user store to plug into the ASP .NET Core Identity system.</span>\r\n<br /><br />\r\nIn the <a href=\"/blog/post/create-custom-password-hasher-for-aspnet-core-identity-v3-update\">previous post</a> I looked at how to create a custom password hasher for ASP .NET Core Identity. In this post, I continue customizing the Identity system by creating a custom User Store. This is done by providing custom implementations to the <code>IUserPasswordStore</code> and <code>IUserEmailStore</code> interfaces. I'm going to create in-memory implementations of these two interfaces. This will not work in a real application because all the users are deleted when the application restarts but is good for demo purposes. This tutorial requires <a target=\"_blank\" href=\"https://visualstudio.microsoft.com/downloads/\">Visual Studio 2019</a> and <a target=\"_blank\" href=\"https://www.microsoft.com/net/download\">dotnet core 3.x</a>. The entire sample project is available on <a href=\"https://github.com/cwl157/asp-net-core-auth-examples/tree/master\" target=\"_blank\">Github</a>.\r\n<br /><br />\r\n<h3>Create Starting Application</h3>\r\n<br />\r\nStart by opening Visual Studio 2019 and create a new ASP .NET Core Web Application project. Click Next.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity-v3-update/create_project.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nProvide a name for the project. I named it <code>DotNetCoreAuthExamples.CustomUserStore</code> but you can name it anything you like. Click Create.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity-v3-update/create_project_2.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nChoose <code>.NET Core</code> and <code>ASP.NET Core 3.x</code>, depending on your version, from the dropdowns at the top. Select <code>Web Application (Model-View-Controller)</code> for the template and under the Authentication header click Change and pick <code>Individual User Accounts</code>. Click Create.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity-v3-update/create_project_3.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nAfter the project is created, debug it from Visual Studio to make sure the template is working. After the web app loads, stop debugging. At this point we have an ASP .NET core web app project with basic user authentication. In the sections that follow, we will create our custom implementation.\r\n<h3>Data Access</h3>\r\n<br />\r\nSince we're storing users in memory, we don't need the database so you can delete the Data folder.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity-v3-update/delete_migrations_folder.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nThe next step is to create the \"data access\" class to store the users in memory. This class has nothing to do with ASP .NET Core Identity but we need a place to perform basic CRUD operations on our in-memory list of users. Create a new C# class and name it <code>InMemoryUserDataAccess</code>. The full class is below to copy and paste.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class InMemoryUserDataAccess\r\n{\r\n     private List&lt;IdentityUser&gt; _users;\r\n     public InMemoryUserDataAccess()\r\n     {\r\n         _users = new List&lt;IdentityUser&gt;();\r\n     }\r\n     public bool CreateUser(IdentityUser user)\r\n     {\r\n         _users.Add(user);\r\n         return true;\r\n     }\r\n\r\n     public IdentityUser GetUserById(string id)\r\n     {\r\n         return _users.FirstOrDefault(u =&gt; u.Id == id);\r\n     }\r\n\r\n     public IdentityUser GetByEmail(string email)\r\n     {\r\n         return _users.FirstOrDefault(u =&gt; u.NormalizedEmail == email);\r\n     }\r\n\r\n     public IdentityUser GetUserByUsername(string username)\r\n     {\r\n         return _users.FirstOrDefault(u =&gt; u.NormalizedUserName == username);\r\n     }\r\n\r\n     public string GetNormalizedUsername(IdentityUser user)\r\n     {\r\n         return user.NormalizedUserName;\r\n     }\r\n\r\n     public bool Update(IdentityUser user)\r\n     {\r\n         // Since get user gets the user from the same in-memory list,\r\n         // the user parameter is the same as the object in the list, so nothing needs to be updated here.\r\n         return true;\r\n     }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>Create Custom User Store</h3>\r\n<br />\r\nThe third step is to create the custom user store. The user store in ASP .NET identity can be a complex system of functionality. Luckily, this functionality is broken out into a series of interfaces so we can choose what functionality we want our user store to support. To keep it simple, we're going to implement the <code>IUserPasswordStore</code> and <code>IUserEmailStore</code> interfaces. This is enough to get us started. There are a lot of other interfaces for handling claims, phone numbers, 2 factor authentication, account lockout, etc. <a target=\"_blank\" href=\"https://docs.microsoft.com/en-us/aspnet/identity/overview/extensibility/overview-of-custom-storage-providers-for-aspnet-identity#userstore\">This microsoft doc</a> goes into more detail on all the store interfaces.\r\n<br /><br />\r\nCreate a new class named <code>InMemoryUserStore </code>. The full implementation is below. Notice the dependency to <code>InMemoryUserDataAccess</code> we created above. I did not implement delete. I'll leave that up to you.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic class InMemoryUserStore : IUserPasswordStore&lt;IdentityUser&gt;, IUserEmailStore&lt;IdentityUser&gt;\r\n{\r\n    private InMemoryUserDataAccess _dataAccess;\r\n    public InMemoryUserStore(InMemoryUserDataAccess da)\r\n    {\r\n        _dataAccess = da;\r\n    }\r\n\r\n    public Task&lt;IdentityResult&gt; CreateAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;IdentityResult&gt;.Run(() =&gt;\r\n        {\r\n            IdentityResult result = IdentityResult.Failed();\r\n            bool createResult = _dataAccess.CreateUser(user);\r\n\r\n            if (createResult)\r\n            {\r\n                result = IdentityResult.Success;\r\n            }\r\n\r\n            return result;\r\n        });\r\n    }\r\n\r\n    public Task&lt;IdentityResult&gt; DeleteAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public void Dispose()\r\n    {\r\n\r\n    }\r\n\r\n    public Task&lt;IdentityUser&gt; FindByEmailAsync(string normalizedEmail, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;IdentityUser&gt;.Run(() =&gt;\r\n        {\r\n            return _dataAccess.GetByEmail(normalizedEmail);\r\n        });\r\n    }\r\n\r\n    public Task&lt;IdentityUser&gt; FindByIdAsync(string userId, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;IdentityUser&gt;.Run(() =&gt;\r\n        {\r\n            return _dataAccess.GetUserById(userId);\r\n        });\r\n    }\r\n\r\n    public Task&lt;IdentityUser&gt; FindByNameAsync(string normalizedUserName, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;IdentityUser&gt;.Run(() =&gt;\r\n        {\r\n            return _dataAccess.GetUserByUsername(normalizedUserName);\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetEmailAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.Email;\r\n        });\r\n    }\r\n\r\n    public Task&lt;bool&gt; GetEmailConfirmedAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;bool&gt;.Run(() =&gt;\r\n        {\r\n            return user.EmailConfirmed;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetNormalizedEmailAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.NormalizedEmail;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetNormalizedUserNameAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.NormalizedUserName;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetPasswordHashAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt; { return user.PasswordHash; });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetUserIdAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.Id;\r\n        });\r\n    }\r\n\r\n    public Task&lt;string&gt; GetUserNameAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;string&gt;.Run(() =&gt;\r\n        {\r\n            return user.UserName;\r\n        });\r\n    }\r\n\r\n    public Task&lt;bool&gt; HasPasswordAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;bool&gt;.Run(() =&gt; { return true; });\r\n    }\r\n\r\n    public Task SetEmailAsync(IdentityUser user, string email, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt; {\r\n            user.Email = email;\r\n        });\r\n    }\r\n\r\n    public Task SetEmailConfirmedAsync(IdentityUser user, bool confirmed, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.EmailConfirmed = confirmed;\r\n        });\r\n    }\r\n\r\n    public Task SetNormalizedEmailAsync(IdentityUser user, string normalizedEmail, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.NormalizedEmail = normalizedEmail;\r\n        });\r\n    }\r\n\r\n    public Task SetNormalizedUserNameAsync(IdentityUser user, string normalizedName, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.NormalizedUserName = normalizedName;\r\n        });\r\n    }\r\n\r\n    public Task SetPasswordHashAsync(IdentityUser user, string passwordHash, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt; { user.PasswordHash = passwordHash; });\r\n    }\r\n\r\n    public Task SetUserNameAsync(IdentityUser user, string userName, CancellationToken cancellationToken)\r\n    {\r\n        return Task.Run(() =&gt;\r\n        {\r\n            user.UserName = userName;\r\n            user.NormalizedUserName = userName.ToUpper();\r\n        });\r\n    }\r\n\r\n    public Task&lt;IdentityResult&gt; UpdateAsync(IdentityUser user, CancellationToken cancellationToken)\r\n    {\r\n        return Task&lt;IdentityResult&gt;.Run(() =&gt;\r\n        {\r\n            IdentityResult result = IdentityResult.Failed();\r\n            bool updateResult = _dataAccess.Update(user);\r\n\r\n            if (updateResult)\r\n            {\r\n                result = IdentityResult.Success;\r\n            }\r\n\r\n            return result;\r\n        });\r\n    }\r\n}\r\n</code>\r\n</pre>\r\n<br />\r\n<h3>Configure Services</h3>\r\n<br />\r\nThe dependency injection support in ASP .NET Core MVC makes it easy to use our implementation. The <code>ConfigureServices</code> method in the <code>Startup</code> class is where we inject our custom classes. First add the <code>InMemoryDataAccess</code> class as a singleton to store our list of users. Add this line <code class=\"language-csharp\">services.AddSingleton&lt;InMemoryUserDataAccess&gt;();</code>. Now we need to tell the Identity system to use our custom user store. Replace the EntityFramework user store with our own by adding <code class=\"language-csharp\">.AddUserStore&lt;InMemoryUserStore&gt;();</code>. We can also remove references to <code>ApplicationDbContext</code> and the Data namespace because we're not using Entity Framework anymore. The final <code>ConfigureServices</code> method is below.\r\n<pre>\r\n<code class=\"language-csharp\">\r\npublic void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddSingleton&lt;InMemoryUserDataAccess&gt;();\r\n    services.AddDefaultIdentity&lt;IdentityUser&gt;(options =&gt; options.SignIn.RequireConfirmedAccount = true)\r\n        .AddUserStore&lt;InMemoryUserStore&gt;();\r\n    services.AddControllersWithViews();\r\n    services.AddRazorPages();\r\n}\r\n</code>\r\n</pre>\r\n<h3>Test It</h3>\r\n<br />\r\nThe only thing left to do is test. Build and debug the project from Visual Studio. Click the Register button in the upper right corner. Enter an email and password and confirm the password and click Register.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity-v3-update/register.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nA Register confirmation page loads next. Click \"Click here to confirm your account\".\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity-v3-update/confirm.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nThe home page loads. Click \"Login\" in the upper right. Enter the email and password that you just registered and click the login button.\r\n<br />\r\n<img src=\"/data/blog/posts/img/create-custom-user-store-for-aspnet-core-identity-v3-update/login.PNG\" style=\"width:75%;\" />\r\n<br /><br />\r\nThe homepage reloads and the Register button is replaced with a greeting Hello &lt;email&gt;! Click the Logout link next to this greeting and it redirects to the home page with the Register and Login links. If you stop and restart debugging that user will no longer exist because they were only stored in memory.\r\n<h3>Conclusion</h3>\r\n<br />\r\nThat concludes how to setup a basic custom user store for ASP .NET Core Identity. The full code example <a href=\"https://github.com/cwl157/asp-net-core-auth-examples/tree/master\">is on GitHub</a>. We created a custom class implementing only the interfaces we needed and used dependency injection to swap implementations. User management is a complex topic with many features available for both security and user experience. Hopefully, this is a good starting point for customizing specific features around user management in your ASP .NET Core application.","author":"Carl Layton","publishedDate":"2020-03-22T17:45:00Z","friendlyUri":"create-custom-user-store-for-aspnet-core-identity-v3-update","isPublished":true,"previousPostUri":"create-custom-password-hasher-for-aspnet-core-identity-v3-update","previousPostTitle":"Create Custom Password Hasher for ASP .NET Core Identity - .NET Core 3 Update","nextPostUri":"example-of-the-strategy-pattern","nextPostTitle":"Example of the Strategy Pattern","isFeatured":true,"tags":["ASP .NET Core","Authentication","csharp","Identity"]}