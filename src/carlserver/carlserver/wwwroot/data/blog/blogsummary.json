[{"id":1,"title":"Using C# dynamic Keyword To Replace Data Transfer Objects","summary":"For this post I'm going to show 3 examples of using the C# dynamic keyword when deserializing input data instead of using data transfer objects. Many modern applications need to accept data from a variety of sources. Often times we create data transfer objects just to handle requests and responses to and from the data source. Using dynamic in C# reduces the need for data transfer objects and keeps the logic that depends on the 3rd party data source contained to one place.","body":"","author":"Carl Layton","publishedDate":"2017-12-10T06:00:00Z","friendlyUri":"using-c#-dynamic-keyword-to-replace-data-transfer-objects","isPublished":true,"previousPostUri":null,"previousPostTitle":null,"nextPostUri":null,"nextPostTitle":null,"tags":["csharp","ASP .NET"]},{"id":2,"title":"Using Javascript Promises for Application Logic in an AngularJS Service","summary":"The example in this post shows how the $q service can be used to harness the power of javascript promises to perform application logic in an AngularJS application. This can help keep application code organized and separate responsibilities among controllers and services.","body":"","author":"Carl Layton","publishedDate":"2017-12-17T12:00:00Z","friendlyUri":"using-javascript-promises-for-application-logic-in-an-angularjs-service","isPublished":true,"previousPostUri":null,"previousPostTitle":null,"nextPostUri":null,"nextPostTitle":null,"tags":["AngularJS","javascript"]},{"id":3,"title":"AngularJS Route Resolve Example","summary":"The resolve property is attached to a route in AngularJS to provide a list of dependencies for the route. The data from this list is injected into the route controller and if any of the dependencies are promises, the promise will be resolved before the controller is instantiated. This helps keep the controller clean because any data the controller depends on can be injected into it instead of the controller retrieving that data itself. This post will go through an example of using the resolve property and show the differences between using a resolve property versus putting the fetch code in the controller directly.","body":"","author":"Carl Layton","publishedDate":"2018-01-10T13:30:00Z","friendlyUri":"angularjs-route-resolve-example","isPublished":true,"previousPostUri":null,"previousPostTitle":null,"nextPostUri":null,"nextPostTitle":null,"tags":["AngularJS","javascript"]},{"id":4,"title":"AngularJS Route Resolve Failed Promise Example","summary":"In the <a href=\"/blog/post/angularjs-route-resolve-example\">previous post</a> I looked at how the resolve property of an AngularJS route can be used to pass dependencies to a controller. In that example the resolve property in the route configuration called a service that returned a promise. The resolve property then passes the result of the promise to the controller when it is instantiated. The question that came up is what if there is an error and the promise is rejected instead of resolved? That's what I'll be answering in this post.","body":"","author":"Carl Layton","publishedDate":"2018-01-18T06:00:00Z","friendlyUri":"angularjs-route-resolve-failed-promise-example","isPublished":true,"previousPostUri":null,"previousPostTitle":null,"nextPostUri":null,"nextPostTitle":null,"tags":["AngularJS","javascript"]},{"id":5,"title":"Create Fake Data Using Json Schema Faker","summary":"In this post I will look at how to create fake data using Json Schema Faker and faker.js. Json Schema Faker is a node package that uses fake data generators and a schema defined in JSON to create fake data. Any application that handles data in the JSON format can use this for testing, prototyping, or general development. I will cover how to create a json schema and how to generate mock data for it using Json Schema Faker. This tutorial assumes basic knowledge of javacsript, NodeJS, and NPM and that NodeJS and NPM are installed.","body":"","author":"Carl Layton","publishedDate":"2018-03-25T16:30:00Z","friendlyUri":"create-fake-data-using-json-schema-faker","isPublished":true,"previousPostUri":null,"previousPostTitle":null,"nextPostUri":null,"nextPostTitle":null,"tags":["javascript","json","mock data"]},{"id":6,"title":"Applying The Strategy Pattern To Vary Data Access Methods In C#","summary":"The strategy pattern is a design pattern that allows for multiple implementations, or strategies, to be used interchangeably. A data access layer can make good use of the strategy pattern because it can abstract out the implementation of the actual data access mechanism from the consumer of the data access layer. In this post, I'll look at an example that uses the strategy pattern to implement 2 different data access methods and switching between them is as easy as updating the dependency injector configuration.","body":"","author":"Carl Layton","publishedDate":"2018-04-04T11:30:00Z","friendlyUri":"applying-the-strategy-pattern-to-vary-data-access-methods-in-csharp","isPublished":true,"previousPostUri":null,"previousPostTitle":null,"nextPostUri":null,"nextPostTitle":null,"tags":["csharp","ASP .NET core MVC","design patterns","strategy pattern"]}]